-- ============================================================================
-- Corrected Orders INSERT Statement
-- Uses formatted_order_id properly and includes merchant_parent_id
-- ============================================================================

-- First, ensure merchant_parent_id is set from merchant_stores
-- This query will get the parent_id for store_id = 25
-- You may need to adjust the store_id based on your data

-- Insert/Update orders with correct formatted_order_id and merchant_parent_id
-- Note: This assumes the orders already exist. If inserting new orders, 
-- the trigger will auto-generate formatted_order_id

-- Option 1: UPDATE existing orders (recommended)
-- First update merchant_parent_id
UPDATE orders_core oc
SET merchant_parent_id = COALESCE(
  (SELECT parent_id FROM merchant_stores WHERE id = oc.merchant_store_id),
  oc.merchant_parent_id
)
WHERE oc.id IN (25, 26, 27)
  AND oc.merchant_parent_id IS NULL;

-- Then update formatted_order_id using a DO block (window functions not allowed in UPDATE)
DO $$
DECLARE
  rec RECORD;
  food_counter BIGINT := 100001;
  parcel_counter BIGINT := 10001;
  ride_counter BIGINT := 10001;
  prefix TEXT;
  formatted_id TEXT;
BEGIN
  -- Process orders ordered by id to maintain sequence
  FOR rec IN 
    SELECT id, order_type FROM orders_core 
    WHERE id IN (25, 26, 27)
      AND formatted_order_id IS NULL
    ORDER BY id ASC
  LOOP
    -- Get prefix based on order_type (inline version if function doesn't exist)
    CASE rec.order_type::TEXT
      WHEN 'food' THEN prefix := 'GMF';
      WHEN 'parcel' THEN prefix := 'GMC';
      WHEN 'ride' THEN prefix := 'GMP';
      WHEN '3pl' THEN prefix := 'GM3';
      ELSE prefix := 'GMF'; -- Default to food
    END CASE;
    
    -- Generate formatted ID based on order_type
    IF rec.order_type::TEXT = 'food' THEN
      formatted_id := prefix || LPAD(food_counter::TEXT, 6, '0');
      food_counter := food_counter + 1;
    ELSIF rec.order_type::TEXT = 'parcel' THEN
      formatted_id := prefix || LPAD(parcel_counter::TEXT, 5, '0');
      parcel_counter := parcel_counter + 1;
    ELSIF rec.order_type::TEXT = 'ride' THEN
      formatted_id := prefix || LPAD(ride_counter::TEXT, 5, '0');
      ride_counter := ride_counter + 1;
    ELSE
      -- Default to food format for unknown types
      formatted_id := 'GMF' || LPAD(food_counter::TEXT, 6, '0');
      food_counter := food_counter + 1;
    END IF;
    
    UPDATE orders_core
    SET formatted_order_id = formatted_id
    WHERE id = rec.id;
  END LOOP;
END $$;

-- Option 2: Corrected INSERT statement (if you need to insert new orders)
-- Replace the INSERT with this corrected version:

INSERT INTO "public"."orders_core" (
  "order_uuid", 
  "order_type", 
  "order_source", 
  "external_ref", 
  "rider_id", 
  "customer_id", 
  "merchant_store_id", 
  "merchant_parent_id",  -- Now properly set from merchant_stores
  "pickup_address_raw", 
  "pickup_address_normalized", 
  "pickup_address_geocoded", 
  "pickup_lat", 
  "pickup_lon", 
  "drop_address_raw", 
  "drop_address_normalized", 
  "drop_address_geocoded", 
  "drop_lat", 
  "drop_lon", 
  "distance_km", 
  "eta_seconds", 
  "pickup_address_deviation_meters", 
  "drop_address_deviation_meters", 
  "distance_mismatch_flagged", 
  "fare_amount", 
  "commission_amount", 
  "rider_earning", 
  "status", 
  "current_status", 
  "payment_status", 
  "payment_method", 
  "risk_flagged", 
  "risk_reason", 
  "is_bulk_order", 
  "bulk_order_group_id", 
  "cancellation_reason_id", 
  "cancelled_at", 
  "cancelled_by", 
  "cancelled_by_id", 
  "items", 
  "cancelled_by_type", 
  "cancellation_details"
  -- formatted_order_id will be auto-generated by trigger
) 
SELECT 
  gen_random_uuid(), -- order_uuid
  'food'::order_type,
  'internal'::order_source_type,
  NULL,
  1003,
  17,
  25,
  (SELECT parent_id FROM merchant_stores WHERE id = 25), -- merchant_parent_id from store
  '123 Restaurant Street, City',
  NULL,
  NULL,
  28.613900,
  77.209000,
  '456 Customer Avenue, City',
  NULL,
  NULL,
  28.704100,
  77.102500,
  5.20,
  NULL,
  NULL,
  NULL,
  FALSE,
  150.00,
  15.00,
  135.00,
  'assigned'::order_status_type,
  'READY_FOR_PICKUP',
  'pending'::payment_status_type,
  'online'::payment_mode_type,
  FALSE,
  NULL,
  FALSE,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  '[{"id": 1, "name": "Margherita Pizza", "price": 250.00, "total": 500.00, "category": "Pizza", "quantity": 2, "customizations": ["Extra Cheese"]}, {"id": 2, "name": "Garlic Bread", "price": 80.00, "total": 80.00, "category": "Appetizer", "quantity": 1}]'::JSONB,
  NULL,
  NULL
WHERE NOT EXISTS (SELECT 1 FROM orders_core WHERE id = 25);

-- Repeat for order 26
INSERT INTO "public"."orders_core" (
  "order_uuid", "order_type", "order_source", "external_ref", "rider_id", "customer_id", 
  "merchant_store_id", "merchant_parent_id", "pickup_address_raw", "pickup_address_normalized", 
  "pickup_address_geocoded", "pickup_lat", "pickup_lon", "drop_address_raw", 
  "drop_address_normalized", "drop_address_geocoded", "drop_lat", "drop_lon", 
  "distance_km", "eta_seconds", "pickup_address_deviation_meters", 
  "drop_address_deviation_meters", "distance_mismatch_flagged", "fare_amount", 
  "commission_amount", "rider_earning", "status", "current_status", "payment_status", 
  "payment_method", "risk_flagged", "risk_reason", "is_bulk_order", 
  "bulk_order_group_id", "cancellation_reason_id", "cancelled_at", "cancelled_by", 
  "cancelled_by_id", "items", "cancelled_by_type", "cancellation_details"
) 
SELECT 
  gen_random_uuid(),
  'food'::order_type,
  'internal'::order_source_type,
  NULL,
  1003,
  18,
  25,
  (SELECT parent_id FROM merchant_stores WHERE id = 25),
  '789 Restaurant Lane, City',
  NULL,
  NULL,
  28.613900,
  77.209000,
  '321 Customer Road, City',
  NULL,
  NULL,
  28.704100,
  77.102500,
  3.80,
  NULL,
  NULL,
  NULL,
  FALSE,
  120.00,
  12.00,
  108.00,
  'in_transit'::order_status_type,
  'OUT_FOR_DELIVERY',
  'completed'::payment_status_type,
  'online'::payment_mode_type,
  FALSE,
  NULL,
  FALSE,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  '[{"id": 3, "name": "Chicken Biryani", "price": 180.00, "total": 180.00, "category": "Main Course", "quantity": 1, "spice_level": "Medium"}]'::JSONB,
  NULL,
  NULL
WHERE NOT EXISTS (SELECT 1 FROM orders_core WHERE id = 26);

-- Repeat for order 27
INSERT INTO "public"."orders_core" (
  "order_uuid", "order_type", "order_source", "external_ref", "rider_id", "customer_id", 
  "merchant_store_id", "merchant_parent_id", "pickup_address_raw", "pickup_address_normalized", 
  "pickup_address_geocoded", "pickup_lat", "pickup_lon", "drop_address_raw", 
  "drop_address_normalized", "drop_address_geocoded", "drop_lat", "drop_lon", 
  "distance_km", "eta_seconds", "pickup_address_deviation_meters", 
  "drop_address_deviation_meters", "distance_mismatch_flagged", "fare_amount", 
  "commission_amount", "rider_earning", "status", "current_status", "payment_status", 
  "payment_method", "risk_flagged", "risk_reason", "is_bulk_order", 
  "bulk_order_group_id", "cancellation_reason_id", "cancelled_at", "cancelled_by", 
  "cancelled_by_id", "items", "cancelled_by_type", "cancellation_details"
) 
SELECT 
  gen_random_uuid(),
  'food'::order_type,
  'internal'::order_source_type,
  NULL,
  1003,
  19,
  25,
  (SELECT parent_id FROM merchant_stores WHERE id = 25),
  '555 Restaurant Blvd, City',
  NULL,
  NULL,
  28.613900,
  77.209000,
  '999 Customer Street, City',
  NULL,
  NULL,
  28.704100,
  77.102500,
  4.50,
  NULL,
  NULL,
  NULL,
  FALSE,
  200.00,
  20.00,
  180.00,
  'cancelled'::order_status_type,
  'CANCELLED',
  'refunded'::payment_status_type,
  'online'::payment_mode_type,
  FALSE,
  NULL,
  FALSE,
  NULL,
  NULL,
  '2026-02-17 07:12:10.326349+00'::TIMESTAMPTZ,
  'store',
  NULL,
  '[{"id": 4, "name": "Veg Thali", "price": 150.00, "total": 300.00, "category": "Thali", "quantity": 2}]'::JSONB,
  'store',
  '{"reason": "Item unavailable", "store_id": 25, "initiated_by": "merchant_portal"}'::JSONB
WHERE NOT EXISTS (SELECT 1 FROM orders_core WHERE id = 27);

-- After INSERT, formatted_order_id will be auto-generated by trigger
-- But if you want to ensure they match specific values, run this UPDATE:

UPDATE orders_core
SET formatted_order_id = CASE id
  WHEN 25 THEN 'GMF100001'
  WHEN 26 THEN 'GMF100002'
  WHEN 27 THEN 'GMF100003'
  ELSE formatted_order_id
END
WHERE id IN (25, 26, 27);

-- Sync to orders_food
UPDATE orders_food of
SET formatted_order_id = oc.formatted_order_id
FROM orders_core oc
WHERE of.order_id = oc.id
  AND oc.id IN (25, 26, 27)
  AND oc.formatted_order_id IS NOT NULL;
